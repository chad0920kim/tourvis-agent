// dashboard.js - Ìà¨Ïñ¥ÎπÑÏä§ ÌÜµÌï© ÎåÄÏãúÎ≥¥Îìú JavaScript (Ïã§Ï†ú API Ï†ÑÏö©) - mrk2

// ÏÑ§Ï†ï - Goorm Í≥µÍ∞ú ÎèÑÎ©îÏù∏ ÏÇ¨Ïö©
const API_BASE_URL = window.location.hostname === 'chad0920kim.github.io' 
    ? 'https://cxdashboard.run.goorm.site'  // Goorm Í≥µÍ∞ú ÎèÑÎ©îÏù∏
    : 'http://localhost:8505';  // Î°úÏª¨ÏóêÏÑúÎäî HTTP ÏÇ¨Ïö©

console.log(`üîó Dashboard API URL (Goorm): ${API_BASE_URL}`);

let trendChart, avgChart, matchStatusChart, qaTimeChart, responseRateChart;
let currentFeedbackFilter = 'all';
let allFeedbackData = [];
let allQAData = [];
let currentStats = {};

// Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
function updateConnectionStatus(isConnected, message = '') {
    const statusElement = document.getElementById('connectionStatus');
    const textElement = document.getElementById('connectionText');

    if (isConnected) {
        statusElement.className = 'connection-status connected';
        textElement.textContent = message || 'API Ïó∞Í≤∞Îê®';
    } else {
        statusElement.className = 'connection-status disconnected';
        textElement.textContent = message || 'API Ïó∞Í≤∞ Ïã§Ìå®';
    }
}

// API Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ (Ïó¨Îü¨ ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏãúÎèÑ)
async function testApiConnection() {
    const healthEndpoints = [
        '/health',
        '/api/health', 
        '/status',
        '/ping',
        '/'
    ];
    
    console.log('üîç API Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Ï§ë...');
    updateConnectionStatus(false, 'API Ïó∞Í≤∞ ÌôïÏù∏ Ï§ë...');

    for (const endpoint of healthEndpoints) {
        try {
            console.log(`ÏãúÎèÑ Ï§ë: ${API_BASE_URL}${endpoint}`);
            const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                method: 'GET',
                signal: AbortSignal.timeout(3000)
            });

            if (response.ok) {
                const contentType = response.headers.get('content-type');
                let data = {};
                
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    data = { service: 'Server', status: 'ok' };
                }
                
                console.log(`‚úÖ API Ïó∞Í≤∞ ÏÑ±Í≥µ (${endpoint}):`, data);
                updateConnectionStatus(true, `API Ïó∞Í≤∞Îê® (${data.service || 'Server'})`);
                return true;
            }
        } catch (error) {
            console.log(`‚ùå ${endpoint} Ïã§Ìå®:`, error.message);
        }
    }

    // Î™®Îì† ÏóîÎìúÌè¨Ïù∏Ìä∏ Ïã§Ìå® Ïãú
    console.error('‚ùå Î™®Îì† API ÏóîÎìúÌè¨Ïù∏Ìä∏ Ïó∞Í≤∞ Ïã§Ìå®');
    updateConnectionStatus(false, 'API ÏÑúÎ≤Ñ ÎØ∏ÏùëÎãµ');
    
    return false;
}

// ÌÉ≠ Ï†ÑÌôò Ìï®Ïàò
function switchTab(tabName) {
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
    });

    document.querySelectorAll('.tab-button').forEach(button => {
        button.classList.remove('active');
    });

    document.getElementById(tabName + 'Content').classList.add('active');
    document.getElementById(tabName + 'Tab').classList.add('active');

    if (tabName === 'feedback') {
        refreshData();
    } else if (tabName === 'conversations') {
        refreshConversationData();
    }
}

// ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ (Í∞úÏÑ†Îêú Ïò§Î•ò Ï≤òÎ¶¨)
async function fetchStats(days = 7) {
    const statsEndpoints = [
        `/api/stats?days=${days}`,
        `/stats?days=${days}`,
        `/admin/stats?days=${days}`
    ];

    for (const endpoint of statsEndpoints) {
        try {
            console.log(`üìä ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠: ${API_BASE_URL}${endpoint}`);
            const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                const data = await response.json();
                console.log('‚úÖ ÌÜµÍ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏã†:', data);
                return data;
            } else if (response.status !== 404) {
                console.warn(`‚ö†Ô∏è ${endpoint} ÏùëÎãµ Ïò§Î•ò: ${response.status}`);
            }
        } catch (error) {
            if (!error.message.includes('404')) {
                console.warn(`‚ö†Ô∏è ${endpoint} ÏöîÏ≤≠ Ïã§Ìå®:`, error.message);
            }
        }
    }

    console.log('üìä API Ïó∞Í≤∞ Ïã§Ìå® - Îπà Îç∞Ïù¥ÌÑ∞ Î∞òÌôò');
    return {
        total_feedback: 0,
        positive: 0,
        negative: 0,
        satisfaction_rate: 0,
        unique_users: 0
    };
}

// ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ (Í∞úÏÑ†Îêú Ïò§Î•ò Ï≤òÎ¶¨)
async function fetchFeedback(limit = 50, feedback_type = 'all') {
    const feedbackEndpoints = [
        `/api/feedback?limit=${limit}&feedback_type=${feedback_type}`,
        `/admin/feedback?limit=${limit}&feedback_type=${feedback_type}`,
        `/feedback?limit=${limit}&feedback_type=${feedback_type}`
    ];

    for (const endpoint of feedbackEndpoints) {
        try {
            console.log(`üìù ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠: ${API_BASE_URL}${endpoint}`);
            const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                const data = await response.json();
                console.log('‚úÖ ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ ÏàòÏã†:', data);
                return data;
            } else if (response.status !== 404) {
                console.warn(`‚ö†Ô∏è ${endpoint} ÏùëÎãµ Ïò§Î•ò: ${response.status}`);
            }
        } catch (error) {
            if (!error.message.includes('404')) {
                console.warn(`‚ö†Ô∏è ${endpoint} ÏöîÏ≤≠ Ïã§Ìå®:`, error.message);
            }
        }
    }

    console.log('üìù API Ïó∞Í≤∞ Ïã§Ìå® - Îπà Îç∞Ïù¥ÌÑ∞ Î∞òÌôò');
    return {
        feedback: [],
        total: 0
    };
}

// ÌîºÎìúÎ∞±Í≥º Q&A Îç∞Ïù¥ÌÑ∞ Ïó∞Í≤∞ Ìï®Ïàò
function enrichFeedbackWithQA(feedbackData, qaData) {
    console.log('üîç ÌîºÎìúÎ∞±-Q&A Ïó∞Í≤∞ ÏãúÏûë');
    console.log('üìù ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ Ïàò:', feedbackData.length);
    console.log('üí¨ Q&A Îç∞Ïù¥ÌÑ∞ Ïàò:', qaData.length);
    
    // String similarity calculation function (simple Levenshtein distance based)
    function similarity(str1, str2) {
        if (!str1 || !str2) return 0;
        
        // Normalize: remove spaces, special characters, convert to lowercase
        const normalize = (s) => s.replace(/[\s\W]/g, '').toLowerCase();
        const s1 = normalize(str1);
        const s2 = normalize(str2);
        
        if (s1 === s2) return 1.0;
        if (s1.length === 0 || s2.length === 0) return 0;
        
        // Check inclusion relationship
        if (s1.includes(s2) || s2.includes(s1)) {
            return Math.max(s2.length / s1.length, s1.length / s2.length) * 0.8;
        }
        
        // Simple edit distance calculation
        const matrix = [];
        for (let i = 0; i <= s2.length; i++) {
            matrix[i] = [i];
        }
        for (let j = 0; j <= s1.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= s2.length; i++) {
            for (let j = 1; j <= s1.length; j++) {
                if (s2.charAt(i - 1) === s1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
        
        const distance = matrix[s2.length][s1.length];
        const maxLength = Math.max(s1.length, s2.length);
        return 1 - (distance / maxLength);
    }
    
    return feedbackData.map((feedback, index) => {
        const chatId = feedback.feedback || feedback.chat_id;
        console.log(`\nüîç ÌîºÎìúÎ∞± #${index} Ï≤òÎ¶¨ Ï§ë, Chat ID: ${chatId}`);
        
        const relatedQAs = qaData.filter(qa => qa.chat_id === chatId);
        console.log(`üí¨ Í¥ÄÎ†® Q&A Í∞úÏàò: ${relatedQAs.length}`);
        
        if (relatedQAs.length > 0) {
            let bestMatch = null;
            let bestScore = 0;
            
            // If feedback has original question, match with that
            if (feedback.question && feedback.question.trim()) {
                console.log(`üìù ÌîºÎìúÎ∞± ÏßàÎ¨∏: "${feedback.question}"`);
                
                relatedQAs.forEach(qa => {
                    const score = similarity(feedback.question, qa.question);
                    console.log(`üí¨ Q&A ÏßàÎ¨∏: "${qa.question?.substring(0, 30)}..." - Ïú†ÏÇ¨ÎèÑ: ${score.toFixed(3)}`);
                    
                    if (score > bestScore && score > 0.7) { // Only when similarity > 70%
                        bestScore = score;
                        bestMatch = qa;
                    }
                });
                
                if (bestMatch) {
                    console.log(`‚úÖ ÏßàÎ¨∏ Îß§Ïπ≠ ÏÑ±Í≥µ! Ïú†ÏÇ¨ÎèÑ: ${bestScore.toFixed(3)}`);
                    console.log(`   ÏÑ†ÌÉùÎêú Q&A: ${bestMatch.question?.substring(0, 50)}...`);
                    
                    return {
                        ...feedback,
                        question: bestMatch.question,
                        answer: bestMatch.answer,
                        qa_id: bestMatch.id,
                        match_status: bestMatch.match_status,
                        hasQAData: true,
                        qaCount: relatedQAs.length,
                        matchScore: bestScore
                    };
                }
            }
            
            // If question matching fails, use most recent QA (existing logic)
            console.log(`üìù ÏßàÎ¨∏ Îß§Ïπ≠ Ïã§Ìå®, ÏµúÍ∑º Q&A ÏÇ¨Ïö©`);
            const latestQA = relatedQAs.sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
            })[0];
            
            return {
                ...feedback,
                question: latestQA.question,
                answer: latestQA.answer,
                qa_id: latestQA.id,
                match_status: latestQA.match_status,
                hasQAData: true,
                qaCount: relatedQAs.length,
                matchScore: 0
            };
        }
        
        console.log(`‚ùå Chat ID Îß§Ïπ≠ Ïã§Ìå®`);
        return {
            ...feedback,
            question: feedback.question || '',
            answer: feedback.answer || '',
            hasQAData: false,
            qaCount: 0,
            matchScore: 0
        };
    });
}

// Q&A Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è Ï†ÄÏû•
let globalQAData = [];

async function loadQAData() {
    try {
        const data = await fetchConversations(30, 1000); // ÏµúÍ∑º 30Ïùº, ÏµúÎåÄ 1000Í∞ú
        globalQAData = data.conversations || [];
        allQAData = globalQAData; // Ï†ÑÏó≠ Ï†ÄÏû•
        console.log(`‚úÖ Q&A Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å: ${globalQAData.length}Í∞ú`);
        return globalQAData;
    } catch (error) {
        console.warn('‚ö†Ô∏è Q&A Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error);
        globalQAData = [];
        allQAData = [];
        return [];
    }
}

async function fetchConversations(days = 7, limit = 50) {
    const qaEndpoints = [
        `/api/qa/conversations?days=${days}&limit=${limit}`,
        `/qa/conversations?days=${days}&limit=${limit}`,
        `/conversations?days=${days}&limit=${limit}`
    ];

    for (const endpoint of qaEndpoints) {
        try {
            console.log(`üí¨ Q&A Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠: ${API_BASE_URL}${endpoint}`);
            const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
                signal: AbortSignal.timeout(10000)
            });

            if (response.ok) {
                const data = await response.json();
                console.log('‚úÖ Q&A Îç∞Ïù¥ÌÑ∞ ÏàòÏã†:', data);
                return data;
            } else if (response.status !== 404) {
                console.warn(`‚ö†Ô∏è ${endpoint} ÏùëÎãµ Ïò§Î•ò: ${response.status}`);
            }
        } catch (error) {
            if (!error.message.includes('404')) {
                console.warn(`‚ö†Ô∏è ${endpoint} ÏöîÏ≤≠ Ïã§Ìå®:`, error.message);
            }
        }
    }

    console.log(`üí¨ Q&A API Ïó∞Í≤∞ Ïã§Ìå® - Îπà Îç∞Ïù¥ÌÑ∞ Î∞òÌôò`);
    return {
        conversations: [],
        total: 0,
        stats: {
            total_conversations: 0,
            unique_sessions: 0,
            match_distribution: {
                good: 0,
                bad: 0,
                improve: 0,
                none: 0
            }
        }
    };
}

// ÏùëÎãµÎ•† Í≥ÑÏÇ∞ Ìï®Ïàò
function calculateResponseRate(feedbackCount, qaCount) {
    if (qaCount === 0) return 0;
    return Math.round((feedbackCount / qaCount) * 100);
}

// Í∏∞Í∞ÑÎ≥Ñ ÏùëÎãµÎ•† Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
function generateResponseRateData(feedbackData, qaData, days) {
    const responseRates = [];
    const now = new Date();
    
    for (let i = days - 1; i >= 0; i--) {
        const targetDate = new Date(now);
        targetDate.setDate(targetDate.getDate() - i);
        const dateStr = targetDate.toDateString();
        
        // Ìï¥Îãπ ÎÇ†ÏßúÏùò ÌîºÎìúÎ∞±Í≥º Q&A Ïàò Í≥ÑÏÇ∞
        const dayFeedback = feedbackData.filter(fb => {
            const fbDate = new Date(fb.timestamp);
            return fbDate.toDateString() === dateStr;
        }).length;
        
        const dayQA = qaData.filter(qa => {
            const qaDate = new Date(qa.timestamp);
            return qaDate.toDateString() === dateStr;
        }).length;
        
        const responseRate = calculateResponseRate(dayFeedback, dayQA);
        responseRates.push(responseRate);
    }
    
    return responseRates;
}

// ÏÉàÎ°úÍ≥†Ïπ®
async function refreshData() {
    const days = parseInt(document.getElementById('daysSelect').value);
    try {
        document.getElementById('feedbackList').innerHTML = '<div class="loading">ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>';
        
        // Îç∞Ïù¥ÌÑ∞ Î°úÎìú
        const [stats, qaData] = await Promise.all([
            fetchStats(days),
            globalQAData.length > 0 ? Promise.resolve({conversations: globalQAData}) : fetchConversations(days, 1000)
        ]);
        
        // Q&A Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
        if (qaData.conversations) {
            allQAData = qaData.conversations;
        }
        
        // ÏùëÎãµÎ•† Í≥ÑÏÇ∞
        const totalQA = allQAData.length;
        const responseRate = calculateResponseRate(stats.total_feedback, totalQA);
        
        // ÌÜµÌï© ÌÜµÍ≥Ñ Í∞ùÏ≤¥ ÏÉùÏÑ±
        currentStats = {
            ...stats,
            total_qa: totalQA,
            response_rate: responseRate
        };
        
        updateStatsDisplay(currentStats);
        updateCharts(currentStats, days);
        await loadFeedback(currentFeedbackFilter);
    } catch (error) {
        console.error('Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®:', error);
        showError('Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    }
}

async function refreshConversationData() {
    const days = parseInt(document.getElementById('conversationDaysSelect').value);
    const data = await fetchConversations(days, 100);
    updateConversationStats(data);
    updateConversationCharts(data);
}

// ÌÜµÍ≥Ñ UI ÏóÖÎç∞Ïù¥Ìä∏
function updateStatsDisplay(stats) {
    document.getElementById('totalFeedback').textContent = stats.total_feedback || 0;
    document.getElementById('positiveFeedback').textContent = stats.positive || 0;
    document.getElementById('negativeFeedback').textContent = stats.negative || 0;
    document.getElementById('uniqueUsers').textContent = stats.unique_users || 0;
    document.getElementById('satisfactionRate').textContent = (stats.satisfaction_rate || 0) + '%';
    
    // Q&A Í¥ÄÎ†® ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
    document.getElementById('totalQA').textContent = stats.total_qa || 0;
    document.getElementById('responseRate').textContent = (stats.response_rate || 0) + '%';
    
    // ÏÇ¨Ïö©Ïûê Ï∞∏Ïó¨ÎèÑ Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
    const participationRate = stats.unique_users > 0 
        ? (stats.total_feedback / stats.unique_users).toFixed(2)
        : '0.00';
    
    // ÏÇ¨Ïö©Ïûê Ï∞∏Ïó¨ÎèÑ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    const participationElement = document.getElementById('participationRate');
    if (participationElement) {
        participationElement.textContent = participationRate + 'Ìöå';
    }
}

function updateConversationStats(data) {
  let stats = data.stats;

  // ‚úÖ Fallback: statsÍ∞Ä ÏóÜÏúºÎ©¥ conversationsÎ°ú ÏßÅÏ†ë Í≥ÑÏÇ∞
  if (!stats || !stats.match_distribution) {
    const conversations = data.conversations || [];
    stats = {
      total_conversations: conversations.length,
      unique_sessions: new Set(conversations.map(conv => conv.session_id)).size,
      match_distribution: { good: 0, bad: 0, improve: 0 }
    };

    conversations.forEach(conv => {
      const status = conv.match_status;
      if (status === 1.0) stats.match_distribution.good++;
      else if (status === 0.0) stats.match_distribution.bad++;
      else if (status === 0.5) stats.match_distribution.improve++;
    });
  }

  // ‚úÖ ÎèôÍ∏∞Ìôî Ï∂úÎ†•
  document.getElementById('totalConversations').textContent = stats.total_conversations || 0;
  document.getElementById('totalSessions').textContent = stats.unique_sessions || 0;
  document.getElementById('matchGood').textContent = stats.match_distribution.good || 0;
  document.getElementById('matchBad').textContent = stats.match_distribution.bad || 0;
  document.getElementById('matchImprove').textContent = stats.match_distribution.improve || 0;
}



// Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
function updateCharts(stats, days) {
    // Í∏∞Ï°¥ Ï∞®Ìä∏ ÌååÍ¥¥
    if (trendChart) trendChart.destroy();
    if (avgChart) avgChart.destroy();
    if (responseRateChart) responseRateChart.destroy();

    // ÏãúÍ∞ÑÎ≥Ñ ÌîºÎìúÎ∞± Ï∂îÏù¥ Ï∞®Ìä∏
    const trendCtx = document.getElementById('trendChart').getContext('2d');
    const trendLabels = generateTimeLabels(days);
    const trendData = generateTrendData(stats, days);

    trendChart = new Chart(trendCtx, {
        type: 'line',
        data: {
            labels: trendLabels,
            datasets: [{
                label: 'üëç ÎèÑÏõÄÎê®',
                data: trendData.positive,
                borderColor: '#28a745',
                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                tension: 0.4,
                fill: true
            }, {
                label: 'üëé ÏïÑÏâ¨ÏõÄ',
                data: trendData.negative,
                borderColor: '#dc3545',
                backgroundColor: 'rgba(220, 53, 69, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });

    // ÌîºÎìúÎ∞± Î∂ÑÌè¨ Ï∞®Ìä∏
    const avgCtx = document.getElementById('avgChart').getContext('2d');
    avgChart = new Chart(avgCtx, {
        type: 'doughnut',
        data: {
            labels: ['üëç ÎèÑÏõÄÎê®', 'üëé ÏïÑÏâ¨ÏõÄ'],
            datasets: [{
                data: [stats.positive || 0, stats.negative || 0],
                backgroundColor: ['#28a745', '#dc3545'],
                borderWidth: 2,
                borderColor: '#fff'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                }
            }
        }
    });

    // ÏùëÎãµÎ•† Ï∂îÏù¥ Ï∞®Ìä∏ (ÏÉàÎ°ú Ï∂îÍ∞Ä)
    const responseCtx = document.getElementById('responseRateChart').getContext('2d');
    const responseRateData = generateResponseRateData(allFeedbackData, allQAData, days);
    
    responseRateChart = new Chart(responseCtx, {
        type: 'bar',
        data: {
            labels: trendLabels,
            datasets: [{
                label: 'ÌîºÎìúÎ∞± ÏùëÎãµÎ•† (%)',
                data: responseRateData,
                backgroundColor: '#17a2b8',
                borderColor: '#138496',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        stepSize: 10,
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                }
            }
        }
    });
}

function updateConversationCharts(data) {
    const conversations = data.conversations || [];
    
    // Îß§Ïπò ÏÉÅÌÉú Ï∞®Ìä∏
    if (matchStatusChart) matchStatusChart.destroy();
    
    const matchCtx = document.getElementById('matchStatusChart').getContext('2d');
    let matchGood = 0, matchBad = 0, matchImprove = 0, noMatch = 0;
    
    conversations.forEach(conv => {
        const status = conv.match_status;
        if (status === 1.0) matchGood++;
        else if (status === 0.0) matchBad++;
        else if (status === 0.5) matchImprove++;
        else noMatch++;
    });
    
    matchStatusChart = new Chart(matchCtx, {
        type: 'pie',
        data: {
            labels: ['Îß§Ïπò‚≠ïÔ∏è', 'Îß§Ïπò‚úñÔ∏è', 'Î≥¥Í∞ï‚û°Ô∏è', 'ÎØ∏ÌèâÍ∞Ä'],
            datasets: [{
                data: [matchGood, matchBad, matchImprove, noMatch],
                backgroundColor: ['#28a745', '#dc3545', '#ffc107', '#6c757d'],
                borderWidth: 2,
                borderColor: '#fff'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                }
            }
        }
    });

    // Q&A ÏãúÍ∞Ñ Ï∂îÏù¥ Ï∞®Ìä∏
    if (qaTimeChart) qaTimeChart.destroy();
    
    const timeCtx = document.getElementById('qaTimeChart').getContext('2d');
    qaTimeChart = new Chart(timeCtx, {
        type: 'bar',
        data: {
            labels: ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à', 'ÌÜ†', 'Ïùº'],
            datasets: [{
                label: 'Q&A Ïàò',
                data: [0, 0, 0, 0, 0, 0, 0],
                backgroundColor: '#17a2b8',
                borderColor: '#138496',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

// ÏãúÍ∞Ñ ÎùºÎ≤® ÏÉùÏÑ±
function generateTimeLabels(days) {
    const labels = [];
    const now = new Date();
    
    for (let i = days - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        
        if (days <= 7) {
            labels.push(date.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' }));
        } else {
            labels.push(date.toLocaleDateString('ko-KR', { month: 'numeric', day: 'numeric' }));
        }
    }
    
    return labels;
}

// Ï∂îÏù¥ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
function generateTrendData(stats, days) {
    const positive = [];
    const negative = [];
    
    const avgPositive = Math.floor((stats.positive || 0) / days);
    const avgNegative = Math.floor((stats.negative || 0) / days);
    
    for (let i = 0; i < days; i++) {
        positive.push(avgPositive);
        negative.push(avgNegative);
    }
    
    return { positive, negative };
}

// ÌîºÎìúÎ∞± ÌëúÏãú
async function loadFeedback(type = 'all') {
    currentFeedbackFilter = type;
    document.querySelectorAll('.data-filters button').forEach(btn => btn.classList.remove('active'));
    document.getElementById(type === 'all' ? 'allBtn' : type + 'Btn').classList.add('active');

    const limit = parseInt(document.getElementById('limitSelect').value);
    
    // Load feedback and QA data simultaneously
    const [feedbackData, qaData] = await Promise.all([
        fetchFeedback(limit, type),
        globalQAData.length > 0 ? Promise.resolve(globalQAData) : loadQAData()
    ]);
    
    // Enrich feedback data with QA data
    const enrichedFeedback = enrichFeedbackWithQA(feedbackData.feedback || [], qaData);
    
    allFeedbackData = enrichedFeedback;
    displayFeedback(enrichedFeedback);
}

function displayFeedback(feedbackList) {
    const container = document.getElementById('feedbackList');
    const countElement = document.getElementById('feedbackCount');
    
    countElement.textContent = feedbackList.length + 'Í∞ú';
    
    if (feedbackList.length === 0) {
        container.innerHTML = '<div class="error">ÌëúÏãúÌï† ÌîºÎìúÎ∞±Ïù¥ ÏóÜÏäµÎãàÎã§.</div>';
        return;
    }
    
    const html = feedbackList.map((feedback, index) => {
        const date = new Date(feedback.timestamp).toLocaleDateString('ko-KR', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        
        const typeClass = feedback.feedback === 'positive' ? 'positive' : 'negative';
        const typeText = feedback.feedback === 'positive' ? 'üëç ÎèÑÏõÄÎê®' : 'üëé ÏïÑÏâ¨ÏõÄ';
        
        // Q&A connection status display (with match score)
        let qaStatus = '';
        if (feedback.hasQAData) {
            const matchInfo = feedback.matchScore > 0 ? 
                `ÏßàÎ¨∏Îß§Ïπ≠ ${(feedback.matchScore * 100).toFixed(0)}%` : 
                'ÏµúÍ∑ºQ&A';
            qaStatus = `<span style="color: #28a745; font-weight: 600;">‚úì Q&A Ïó∞Í≤∞Îê® (${feedback.qaCount}Í±¥, ${matchInfo})</span>`;
        } else {
            qaStatus = `<span style="color: #dc3545;">‚óã Q&A ÎØ∏Ïó∞Í≤∞</span>`;
        }
        
        // Match status display
        let matchStatusText = '';
        if (feedback.hasQAData && feedback.match_status !== undefined) {
            const matchLabels = {
                1.0: '<span style="color: #28a745;">‚≠ïÔ∏è Îß§Ïπò</span>',
                0.0: '<span style="color: #dc3545;">‚úñÔ∏è Îß§Ïπò ÏïàÎê®</span>',
                0.5: '<span style="color: #ffc107;">‚û°Ô∏è Î≥¥Í∞ï ÌïÑÏöî</span>'
            };
            matchStatusText = matchLabels[feedback.match_status] || '<span style="color: #6c757d;">- ÎØ∏ÌèâÍ∞Ä</span>';
        }
        
        return `
            <div class="data-item ${typeClass}">
                <div class="data-meta">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span class="data-type ${typeClass}">${typeText}</span>
                        ${matchStatusText}
                    </div>
                    <span>${date}</span>
                </div>
                <div class="data-content">
                    <div class="question">‚ùì ${feedback.question || 'ÏßàÎ¨∏ Ï†ïÎ≥¥ ÏóÜÏùå'}</div>
                    <div class="answer ${index < 5 ? '' : 'collapsed'}" id="answer_${index}">
                        ${feedback.answer || 'ÎãµÎ≥Ä Ï†ïÎ≥¥ ÏóÜÏùå'}
                    </div>
                    ${(feedback.answer && feedback.answer.length > 200) ? 
                        `<button class="expand-toggle" onclick="toggleAnswer(${index})">
                            <span id="toggle_text_${index}">${index < 5 ? 'Ï†ëÍ∏∞' : 'ÎçîÎ≥¥Í∏∞'}</span>
                        </button>` : ''
                    }
                </div>
                <div class="data-details">
                    üí¨ Chat ID: ${feedback.chat_id || feedback.feedback || 'unknown'} | 
                    üåê IP: ${feedback.client_ip || 'unknown'} | 
                    üÜî ÌîºÎìúÎ∞± ID: ${feedback.feedback_id || 'unknown'} | 
                    ${qaStatus}
                    ${feedback.qa_id ? ` | üîó Q&A ID: ${feedback.qa_id}` : ''}
                </div>
            </div>
        `;
