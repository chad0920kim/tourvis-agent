<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>투어비스 에이전트 - 1:1 + route</title>
  <script src="https://unpkg.com/event-source-polyfill@1.0.20/eventsource.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f5f7fa;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      align-items: center;
      overscroll-behavior: none;
    }

    /* 🎯 헤더 추가 */
    #header {
      width: 100%;
      max-width: 600px;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      padding: 15px 20px;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    #header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    #container {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      height: calc(100vh - 60px);
      width: 100%;
      max-width: 600px;
      background: white;
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
    }
    
    #chat {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
    }
    
    .msg {
      margin: 10px 0;
      display: flex;
      flex-direction: column;
      opacity: 0;
      animation: slideIn 0.4s ease-out forwards;
    }
    
    .user, .bot {
      padding: 12px 16px;
      border-radius: 18px;
      max-width: 85%;
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.4;
      font-size: 15px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .user {
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 6px;
    }
    
    .bot {
      background: white;
      border: 1px solid #e1e5e9;
      align-self: flex-start;
      min-height: 20px;
      transition: all 0.2s ease-out;
      border-bottom-left-radius: 6px;
    }
    
    .bot.typo-processing {
      background: linear-gradient(135deg, #fff3cd, #ffeaa7);
      border-color: #f39c12;
    }
    
    .bot.error {
      background: linear-gradient(135deg, #f8d7da, #f5c6cb);
      border-color: #dc3545;
      color: #721c24;
    }
    
    .timestamp {
      font-size: 11px;
      color: #6c757d;
      margin-top: 4px;
      align-self: flex-end;
    }
    
    .user + .timestamp {
      align-self: flex-end;
    }
    
    .bot + .timestamp {
      align-self: flex-start;
    }
    
    #inputBox {
      display: flex;
      padding: 15px;
      border-top: 1px solid #e1e5e9;
      background: white;
      gap: 10px;
      align-items: flex-end;
      position: sticky;
      bottom: 0;
    }
    
    #q {
      flex: 1;
      font-size: 16px;
      padding: 12px 16px;
      border: 1px solid #ccc;
      border-radius: 25px;
      outline: none;
      resize: none;
      min-height: 44px;
      max-height: 100px;
      font-family: inherit;
      transition: border-color 0.2s;
    }
    
    #q:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
    }
    
    #sendBtn {
      width: 44px;
      height: 44px;
      border: none;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.2s;
      flex-shrink: 0;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      user-select: none;
      pointer-events: auto;
      position: relative;
      z-index: 10;
    }
    
    #sendBtn:hover:not(:disabled) {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0,123,255,0.3);
    }
    
    #sendBtn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    #sendBtn:not(:disabled):active {
      transform: scale(0.95);
    }
    
    a {
      color: #007bff;
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: border-color 0.2s;
    }
    
    a:hover {
      border-bottom-color: #007bff;
    }
    
    @keyframes slideIn {
      from { 
        opacity: 0; 
        transform: translateY(10px); 
      }
      to { 
        opacity: 1; 
        transform: translateY(0); 
      }
    }
    
    .typing-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    
    .typing-indicator span {
      width: 6px;
      height: 6px;
      background: #007bff;
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }
    
    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }
    
    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }
    
    @keyframes typing {
      0%, 60%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    .typo-notice {
      background: linear-gradient(135deg, #e7f3ff, #cce7ff);
      border: 1px solid #007bff;
      padding: 10px 14px;
      border-radius: 12px;
      margin: 8px 0;
      font-size: 14px;
      color: #0056b3;
      box-shadow: 0 1px 3px rgba(0,123,255,0.1);
    }

    /* 🎯 모바일 최적화 */
    @media (max-width: 768px) {
      body {
        font-size: 16px; /* iOS 확대 방지 */
      }

      #header {
        padding: 12px 15px;
      }

      #header h1 {
        font-size: 16px;
      }

      #container {
        height: calc(100vh - 50px);
        max-width: 100%;
        box-shadow: none;
      }
      
      #chat {
        padding: 10px;
      }
      
      .msg {
        margin: 8px 0;
      }
      
      .user, .bot {
        max-width: 90%;
        padding: 10px 14px;
        font-size: 14px;
        border-radius: 16px;
      }

      .user {
        border-bottom-right-radius: 4px;
      }

      .bot {
        border-bottom-left-radius: 4px;
      }
      
      .timestamp {
        font-size: 10px;
        margin-top: 3px;
      }
      
      #inputBox {
        padding: 10px;
        gap: 8px;
      }
      
      #q {
        font-size: 16px; /* iOS 확대 방지 */
        padding: 10px 14px;
        border-radius: 20px;
        min-height: 40px;
        max-height: 80px;
      }
      
      #sendBtn {
        width: 40px;
        height: 40px;
        font-size: 16px;
        min-width: 40px;
        min-height: 40px;
        -webkit-tap-highlight-color: rgba(0,123,255,0.3);
      }

      .typo-notice {
        font-size: 13px;
        padding: 8px 12px;
        margin: 6px 0;
      }

      /* 모바일에서 스크롤바 숨기기 */
      #chat::-webkit-scrollbar {
        display: none;
      }

      #chat {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
    }

    /* 🎯 태블릿 최적화 */
    @media (min-width: 769px) and (max-width: 1024px) {
      #container {
        max-width: 700px;
      }
      
      .user, .bot {
        max-width: 80%;
        font-size: 15px;
      }
    }

    /* 🎯 데스크톱 최적화 */
    @media (min-width: 1025px) {
      #container {
        max-width: 600px;
      }
      
      .user, .bot {
        max-width: 75%;
      }

      #sendBtn:hover:not(:disabled) {
        background: linear-gradient(135deg, #0056b3, #004494);
      }
    }

    /* 🎯 다크모드 지원 */
    @media (prefers-color-scheme: dark) {
      body {
        background: #1a1a1a;
        color: #ffffff;
      }

      #header {
        background: linear-gradient(135deg, #0056b3, #004494);
      }

      #container {
        background: #2d2d2d;
        box-shadow: 0 0 20px rgba(255,255,255,0.1);
      }

      #chat {
        background: #2d2d2d;
      }

      .bot {
        background: #3a3a3a;
        border-color: #4a4a4a;
        color: #ffffff;
      }

      #inputBox {
        background: #2d2d2d;
        border-top-color: #4a4a4a;
      }

      #q {
        background: #3a3a3a;
        border-color: #4a4a4a;
        color: #ffffff;
      }

      #q::placeholder {
        color: #aaa;
      }

      .timestamp {
        color: #aaa;
      }
    }

    /* 🎯 접근성 개선 */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01s !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01s !important;
      }
    }
  </style>
</head>
  <body>
  <div id="header">
    <h1>🎯 투어비스 고객센터  - 1:1 + route</h1>
  </div>
  
  <div id="container">
    <div id="chat"></div>
    <div id="inputBox">
      <textarea id="q" placeholder="질문을 입력하세요..." rows="1"></textarea>
      <button id="sendBtn" type="button" aria-label="메시지 전송">
        <span id="sendIcon">➤</span>
      </button>
    </div>
  </div>

<script>
    // 🎯 API 엔드포인트 구성 - 수정된 버전
    // 포트 번호 제거하고 여러 URL 시도하도록 변경
    const API_URLS = [
      "https://tourvis-ai-dxojr.run.goorm.site",     // 기본 HTTPS (포트 제거)
      "https://tourvis-ai-dxojr.run.goorm.site:443", // 표준 HTTPS 포트
      "http://tourvis-ai-dxojr.run.goorm.site",      // HTTP 대체
      "http://tourvis-ai-dxojr.run.goorm.site:8080"  // 원래 URL
    ];

    let API_BASE_URL = API_URLS[0]; // 기본값

    const CHAT_ENDPOINT = "/api/chat"; 
    const FEEDBACK_ENDPOINT = "/api/feedback/simple"; 
    
    // 레거시 엔드포인트 (대체용)
    const LEGACY_CHAT_ENDPOINT = "/chat";
    const LEGACY_FEEDBACK_ENDPOINT = "/feedback-simple";
    
    // 현재 사용할 엔드포인트 설정
    let CURRENT_CHAT_ENDPOINT = CHAT_ENDPOINT;
    let CURRENT_FEEDBACK_ENDPOINT = FEEDBACK_ENDPOINT;

    const chat = document.getElementById("chat");
    const input = document.getElementById("q");
    const sendBtn = document.getElementById("sendBtn");
    const sendIcon = document.getElementById("sendIcon");
    let currentBotContent = null;
    let currentChatId = null; // 현재 채팅 ID
    let currentQAId = null;   // 현재 QA ID (피드백용)
    let serverReachable = false; // 서버 연결 상태
    
    // QA 세션 관리
    let qaSession = {
      chatId: null,          // 채팅 ID
      timestamp: null,       // 타임스탬프
      question: null,        // 질문 내용
      questionHash: null     // 질문 해시
    };

    // 🎯 모바일/PC 감지
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                     window.innerWidth <= 768;

    // 서버 상태 확인 함수 - 개선된 버전
    async function checkServerStatus() {
      console.log("🔍 서버 연결 상태 확인 중...");
      
      // 여러 URL을 순차적으로 시도
      for (const baseUrl of API_URLS) {
        try {
          console.log(`🔍 시도 중: ${baseUrl}`);
          
          // 짧은 타임아웃으로 빠른 확인
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000); // 5초 타임아웃
          
          // 헬스체크 엔드포인트들 시도
          const healthEndpoints = ["/api/admin/health", "/health", "/"];
          
          for (const endpoint of healthEndpoints) {
            try {
              const response = await fetch(`${baseUrl}${endpoint}`, {
                method: 'GET',
                signal: controller.signal,
                headers: {
                  'Accept': 'application/json, text/plain, */*',
                  'Cache-Control': 'no-cache'
                }
              });
              
              clearTimeout(timeoutId);
              
              if (response.ok) {
                console.log(`✅ 서버 연결 성공: ${baseUrl}${endpoint}`);
                API_BASE_URL = baseUrl;
                serverReachable = true;
                return true;
              }
            } catch (endpointError) {
              console.log(`❌ ${baseUrl}${endpoint} 실패:`, endpointError.message);
              continue;
            }
          }
          
          clearTimeout(timeoutId);
          
        } catch (error) {
          console.log(`❌ ${baseUrl} 연결 실패:`, error.message);
          continue;
        }
      }
      
      console.error("❌ 모든 서버 URL 연결 실패");
      serverReachable = false;
      return false;
    }

    // 초기화 시 채팅 ID 가져오기 - 개선된 버전
    async function initChatId() {
      if (!serverReachable) {
        const connected = await checkServerStatus();
        if (!connected) {
          console.error("서버 연결 실패 - 기본 Chat ID 사용");
          currentChatId = `user_${Date.now()}`;
          qaSession.chatId = currentChatId;
          return;
        }
      }
      
      const idEndpoints = ["/api/chat/generate-id", "/generate-chat-id"];
      
      for (const endpoint of idEndpoints) {
        try {
          console.log(`🆔 Chat ID 생성 시도: ${API_BASE_URL}${endpoint}`);
          
          const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            currentChatId = data.chat_id;
            qaSession.chatId = data.chat_id;
            console.log("🆔 Chat ID 생성 성공:", currentChatId);
            return;
          }
        } catch (error) {
          console.error(`Chat ID 생성 실패 (${endpoint}):`, error);
          continue;
        }
      }
      
      // 모든 방법 실패 시 고유 ID 생성
      currentChatId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      qaSession.chatId = currentChatId;
      console.log("🆔 로컬 Chat ID 생성:", currentChatId);
    }

    // 페이지 로드 시 초기화 - 개선된 버전
    window.addEventListener('load', async () => {
      console.log("🚀 애플리케이션 초기화 시작");
      
      // 로딩 상태 표시
      const loadingMsg = document.createElement('div');
      loadingMsg.id = 'loading-status';
      loadingMsg.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        text-align: center; z-index: 9999;
      `;
      loadingMsg.innerHTML = '🔄 서버 연결 중...';
      document.body.appendChild(loadingMsg);
      
      const isConnected = await checkServerStatus();
      
      if (!isConnected) {
        // 서버 연결 실패 시 오프라인 모드 안내
        loadingMsg.innerHTML = `
          <div style="color: #dc3545;">
            <h3>⚠️ 서버 연결 불가</h3>
            <p>다음을 확인해주세요:</p>
            <ul style="text-align: left; margin: 10px 0;">
              <li>인터넷 연결 상태</li>
              <li>서버가 실행 중인지 확인</li>
              <li>방화벽 설정</li>
            </ul>
            <button onclick="location.reload()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
              다시 시도
            </button>
          </div>
        `;
        return;
      } else {
        // 연결 성공 시 Chat ID 초기화
        await initChatId();
        loadingMsg.remove();
        
        // 성공 메시지 잠깐 표시
        const successMsg = document.createElement('div');
        successMsg.style.cssText = `
          position: fixed; top: 20px; right: 20px; background: #28a745; color: white;
          padding: 10px 15px; border-radius: 5px; z-index: 9999;
        `;
        successMsg.textContent = '✅ 서버 연결 성공';
        document.body.appendChild(successMsg);
        setTimeout(() => successMsg.remove(), 3000);
      }
    });

    // 해시 계산 함수 (QA ID 생성용)
    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0; // 32비트 정수로 변환
      }
      return Math.abs(hash % 10000); // 0-9999 사이 값
    }
    
    // QA ID 생성 함수
    function generateQAId(chatId, timestamp, question) {
      const hash = simpleHash(question);
      return `${chatId}_${timestamp}_${hash}`;
    }

    // 🎯 textarea 자동 높이 조절
    input.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 100) + 'px';
    });

    // 🎯 Enter 키 처리
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        if (!e.shiftKey) {
          e.preventDefault();
          e.stopPropagation();
          handleSend();
        }
      }
    });

    function addMsg(role, text, timestamp) {
      const wrap = document.createElement("div");
      wrap.className = "msg";

      const content = document.createElement("div");
      content.className = role;
      content.innerHTML = convertLinks(text);

      const time = document.createElement("div");
      time.className = "timestamp";
      time.textContent = timestamp || new Date().toLocaleTimeString();

      wrap.appendChild(content);
      wrap.appendChild(time);
      chat.appendChild(wrap);
      
      // 부드럽게 스크롤을 맨 아래로
      setTimeout(() => {
        chat.scrollTop = chat.scrollHeight;
      }, 50);
    }

    function convertLinks(text) {
      const urlRegex = /(https?:\/\/[^\s)\]]+)/g;
      return text.replace(urlRegex, url => `<a href="${url}" target="_blank" rel="noopener">${url}</a>`);
    }

    function createTypingIndicator() {
      return `<div class="typing-indicator">답변 생성 중 <span></span><span></span><span></span></div>`;
    }

    function createTypoProcessingIndicator() {
      return `<div class="typing-indicator">🔍 오타 확인 중 <span></span><span></span><span></span></div>`;
    }

    function resetUI() {
      input.disabled = false;
      sendBtn.disabled = false;
      sendIcon.textContent = "➤";
      input.style.height = 'auto';
      currentBotContent = null;
      
      // 모바일에서 포커스 문제 해결
      setTimeout(() => {
        if (!isMobile || !document.activeElement || document.activeElement === document.body) {
          input.focus();
        }
      }, 100);
    }

    // 🎯 전송 버튼 이벤트 (모든 플랫폼 지원)
    sendBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      handleSend();
    });
    
    sendBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
      handleSend();
    });

    // 마우스 이벤트도 추가 (PC 호환성)
    sendBtn.addEventListener('mousedown', function(e) {
      e.preventDefault();
    });

    function handleSend() {
      if (!sendBtn.disabled && !input.disabled) {
        if (!serverReachable) {
          // 서버 상태 재확인
          checkServerStatus().then(isReachable => {
            if (isReachable) {
              send();
            } else {
              alert("서버에 연결할 수 없습니다. 잠시 후 다시 시도해주세요.");
            }
          });
        } else {
          send();
        }
      }
    }

    // 스트림 응답 처리 함수 분리
    async function processStreamResponse(response, botContent, botWrap, timestamp) {
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let fullText = "";
      let isFirstChunk = true;
      let typoNoticeShown = false;

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            console.log('✅ 스트림 완료');
            break;
          }

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\n").filter(line => line.startsWith("data:"));
          
          for (const line of lines) {
            const jsonStr = line.replace(/^data:\s*/, "").trim();
            if (jsonStr === "[DONE]") {
              console.log('🏁 응답 완료');
              resetUI();
              return;
            }

            try {
              const parsed = JSON.parse(jsonStr);
              
              // 특수 상태 처리
              if (parsed.status) {
                switch (parsed.status) {
                  case 'typo_correction':
                    if (!typoNoticeShown) {
                      botContent.className = "bot typo-processing";
                      botContent.innerHTML = createTypoProcessingIndicator();
                      
                      const typoNotice = document.createElement("div");
                      typoNotice.className = "typo-notice";
                      typoNotice.innerHTML = `💡 "<strong>${parsed.original}</strong>" → "<strong>${parsed.corrected}</strong>"로 이해했습니다.`;
                      botWrap.insertBefore(typoNotice, timestamp);
                      typoNoticeShown = true;
                      
                      chat.scrollTop = chat.scrollHeight;
                    }
                    break;
                    
                  case 'timeout':
                    botContent.className = "bot error";
                    botContent.innerHTML = "⏰ 처리 시간이 초과되었습니다.<br>질문을 더 정확하게 입력해 주세요.";
                    resetUI();
                    return;
                    
                  case 'error':
                    botContent.className = "bot error";
                    botContent.innerHTML = `⚠️ 오류 발생: ${parsed.message}`;
                    resetUI();
                    return;
                }
                continue;
              }
              
              // 일반 텍스트 응답 처리
              const delta = parsed?.choices?.[0]?.delta?.content;
              
              if (parsed?.choices?.[0]?.delta?.type === 'html') {
                botContent.innerHTML += delta;
                continue;
              }
              
              if (delta) {
                if (isFirstChunk) {
                  botContent.className = "bot";
                  fullText = "";
                  isFirstChunk = false;
                }
                fullText += delta;
                botContent.innerHTML = convertLinks(fullText);
                
                if (chat.scrollTop + chat.clientHeight >= chat.scrollHeight - 100) {
                  chat.scrollTop = chat.scrollHeight;
                }
              }
            } catch (err) {
              console.warn("응답 파싱 실패:", err, jsonStr);
            }
          }
        }
      } catch (streamError) {
        console.error("스트림 처리 오류:", streamError);
        throw streamError;
      } finally {
        resetUI();
      }
    }

    // 개선된 메시지 전송 함수
    async function send() {
      const message = input.value.trim();
      
      if (!message) {
        return;
      }

      // 전송 버튼 비활성화
      input.disabled = true;
      sendBtn.disabled = true;
      sendIcon.textContent = "⏳";
      
      addMsg("user", message);
      input.value = "";
      input.style.height = 'auto';

      // QA 세션 정보 업데이트
      qaSession.question = message;
      qaSession.timestamp = Math.floor(Date.now() / 1000);
      qaSession.questionHash = simpleHash(message);
      
      currentQAId = generateQAId(currentChatId, qaSession.timestamp, message);
      console.log("🆔 생성된 QA ID:", currentQAId);

      // 봇 메시지 컨테이너 생성
      const botWrap = document.createElement("div");
      botWrap.className = "msg";
      const botContent = document.createElement("div");
      botContent.className = "bot";
      botContent.innerHTML = createTypingIndicator();
      currentBotContent = botContent;
      
      const timestamp = document.createElement("div");
      timestamp.className = "timestamp";
      timestamp.textContent = new Date().toLocaleTimeString();
      
      botWrap.appendChild(botContent);
      botWrap.appendChild(timestamp);
      chat.appendChild(botWrap);
      chat.scrollTop = chat.scrollHeight;

      // 채팅 엔드포인트들을 우선순위에 따라 시도
      const chatEndpoints = [
        { url: `${API_BASE_URL}${CHAT_ENDPOINT}`, name: "새 API" },
        { url: `${API_BASE_URL}${LEGACY_CHAT_ENDPOINT}`, name: "레거시 API" }
      ];
      
      let lastError = null;
      
      for (const endpoint of chatEndpoints) {
        try {
          console.log(`📤 ${endpoint.name} 시도:`, endpoint.url);
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
            console.log(`⏰ ${endpoint.name} 타임아웃`);
          }, 30000); // 30초 타임아웃
          
          const response = await fetch(endpoint.url, {
            method: "POST",
            headers: { 
              "Content-Type": "application/json",
              "Accept": "text/plain, application/json",
              "Cache-Control": "no-cache"
            },
            body: JSON.stringify({ 
              chat_id: currentChatId, 
              message 
            }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);
          
          console.log(`📥 ${endpoint.name} 응답:`, response.status, response.statusText);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          // 성공한 엔드포인트로 업데이트
          if (endpoint.url.includes('/api/chat')) {
            CURRENT_CHAT_ENDPOINT = CHAT_ENDPOINT;
            CURRENT_FEEDBACK_ENDPOINT = FEEDBACK_ENDPOINT;
          } else {
            CURRENT_CHAT_ENDPOINT = LEGACY_CHAT_ENDPOINT;
            CURRENT_FEEDBACK_ENDPOINT = LEGACY_FEEDBACK_ENDPOINT;
          }

          // Chat ID 헤더에서 가져오기
          const responseChatId = response.headers.get("X-Chat-ID");
          if (responseChatId) {
            currentChatId = responseChatId;
            console.log("🆔 서버에서 Chat ID 수신:", currentChatId);
          }

          // 스트림 처리
          await processStreamResponse(response, botContent, botWrap, timestamp);
          return; // 성공적으로 처리됨
          
        } catch (error) {
          lastError = error;
          console.error(`❌ ${endpoint.name} 실패:`, error.message);
          
          // 네트워크 에러인 경우 다음 엔드포인트 시도
          if (error.name === 'AbortError' || error.message.includes('fetch')) {
            continue;
          }
          
          // 기타 에러의 경우 중단
          break;
        }
      }
      
      // 모든 엔드포인트 실패
      console.error("❌ 모든 엔드포인트 실패");
      
      if (currentBotContent) {
        currentBotContent.className = "bot error";
        currentBotContent.innerHTML = `
          <div>⚠️ 연결 실패</div>
          <div style="font-size: 12px; margin-top: 8px; color: #666;">
            ${lastError ? lastError.message : '서버에 연결할 수 없습니다'}
          </div>
          <div style="margin-top: 8px;">
            <button onclick="location.reload()" style="padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
              새로고침
            </button>
          </div>
        `;
      }
      
      // 서버 상태 재확인
      serverReachable = false;
      setTimeout(() => checkServerStatus(), 2000);
      
      resetUI();
    }

    // 🎯 개선된 피드백 전송 함수
    window.sendFeedback = async function(qaId, type) {
      const effectiveQAId = qaId || currentQAId;
      
      if (!effectiveQAId) {
        alert('피드백을 전송할 수 없습니다. 질문을 먼저 해주세요.');
        return;
      }
      
      console.log("📤 피드백 전송:", effectiveQAId, type);
      
      const feedbackEndpoints = [
        { url: `${API_BASE_URL}${FEEDBACK_ENDPOINT}`, name: "새 피드백 API" },
        { url: `${API_BASE_URL}${LEGACY_FEEDBACK_ENDPOINT}`, name: "레거시 피드백 API" }
      ];
      
      for (const endpoint of feedbackEndpoints) {
        try {
          console.log(`📤 ${endpoint.name} 시도:`, endpoint.url);
          
          const response = await fetch(`${endpoint.url}?chat_id=${effectiveQAId}&type=${type}`, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Cache-Control': 'no-cache'
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.status === 'success') {
              alert('피드백이 전송되었습니다. 감사합니다!');
              
              // 성공한 엔드포인트로 업데이트
              if (endpoint.url.includes('/api/feedback')) {
                CURRENT_FEEDBACK_ENDPOINT = FEEDBACK_ENDPOINT;
              } else {
                CURRENT_FEEDBACK_ENDPOINT = LEGACY_FEEDBACK_ENDPOINT;
              }
              return;
            }
          }
        } catch (error) {
          console.error(`❌ ${endpoint.name} 실패:`, error);
          continue;
        }
      }
      
      alert('피드백 전송에 실패했습니다. 나중에 다시 시도해주세요.');
    };

    // 🎯 연결 진단 및 문제 해결 가이드
    window.diagnoseProblem = async function() {
      const results = [];
      
      console.log("🔍 연결 진단 시작...");
      
      // 1. 네트워크 연결 확인
      try {
        await fetch('https://www.google.com/favicon.ico', { mode: 'no-cors' });
        results.push('✅ 인터넷 연결: 정상');
      } catch {
        results.push('❌ 인터넷 연결: 실패');
      }
      
      // 2. 각 서버 URL 테스트
      for (let i = 0; i < API_URLS.length; i++) {
        const url = API_URLS[i];
        try {
          const response = await fetch(`${url}/health`, { 
            method: 'GET',
            signal: AbortSignal.timeout(5000)
          });
          results.push(`✅ 서버 ${i+1} (${url}): ${response.status}`);
        } catch (error) {
          results.push(`❌ 서버 ${i+1} (${url}): ${error.message}`);
        }
      }
      
      // 3. 브라우저 보안 정책 확인
      const isHttps = location.protocol === 'https:';
      const mixedContent = isHttps && API_BASE_URL.startsWith('http:');
      results.push(`🔒 HTTPS 페이지: ${isHttps ? '예' : '아니오'}`);
      results.push(`⚠️ Mixed Content: ${mixedContent ? '문제 있음' : '정상'}`);
      
      // 4. 결과 표시
      const diagDiv = document.createElement('div');
      diagDiv.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        max-width: 500px; width: 90%; z-index: 10000; max-height: 70vh; overflow-y: auto;
      `;
      
      diagDiv.innerHTML = `
        <h3>🔍 연결 진단 결과</h3>
        <div style="font-family: monospace; font-size: 12px; line-height: 1.5;">
          ${results.map(r => `<div>${r}</div>`).join('')}
        </div>
        <hr>
        <h4>💡 해결 방법</h4>
        <ul style="font-size: 14px; line-height: 1.5;">
          <li><strong>Mixed Content 문제:</strong> HTTPS 사이트에서 HTTP 서버 접근 불가</li>
          <li><strong>포트 차단:</strong> 방화벽에서 8080 포트 허용 필요</li>
          <li><strong>서버 미실행:</strong> 투어비스 서버가 실행 중인지 확인</li>
          <li><strong>네트워크 오류:</strong> 인터넷 연결 및 DNS 설정 확인</li>
        </ul>
        <div style="text-align: center; margin-top: 15px;">
          <button onclick="this.parentElement.parentElement.remove()" 
                  style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">
            닫기
          </button>
          <button onclick="location.reload()" 
                  style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">
            새로고침
          </button>
        </div>
      `;
      
      document.body.appendChild(diagDiv);
    };

    // 🎯 개선된 서버 연결 테스트
    window.testServerConnection = async function() {
      const testDiv = document.createElement('div');
      testDiv.style.cssText = `
        position: fixed; bottom: 60px; right: 10px; background: white; padding: 15px;
        border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); z-index: 1000;
        max-width: 300px; font-size: 12px; border: 1px solid #ddd;
      `;
      testDiv.innerHTML = '🔄 연결 테스트 중...';
      document.body.appendChild(testDiv);
      
      const results = [];
      
      // 각 URL과 엔드포인트 조합 테스트
      for (const baseUrl of API_URLS) {
        const endpoints = ['/health', '/api/admin/health', '/generate-chat-id', '/api/chat/generate-id'];
        
        for (const endpoint of endpoints) {
          try {
            const startTime = Date.now();
            const response = await fetch(`${baseUrl}${endpoint}`, {
              method: 'GET',
              signal: AbortSignal.timeout(3000)
            });
            const endTime = Date.now();
            
            results.push({
              url: `${baseUrl}${endpoint}`,
              status: response.status,
              time: endTime - startTime,
              ok: response.ok
            });
          } catch (error) {
            results.push({
              url: `${baseUrl}${endpoint}`,
              error: error.message,
              ok: false
            });
          }
        }
      }
      
      // 결과 표시
      const successResults = results.filter(r => r.ok);
      const failedResults = results.filter(r => !r.ok);
      
      testDiv.innerHTML = `
        <div><strong>연결 테스트 완료</strong></div>
        <div style="color: green; margin: 5px 0;">✅ 성공: ${successResults.length}</div>
        <div style="color: red; margin: 5px 0;">❌ 실패: ${failedResults.length}</div>
        ${successResults.length > 0 ? `
          <div style="margin-top: 10px; font-size: 11px;">
            <strong>사용 가능한 엔드포인트:</strong><br>
            ${successResults.slice(0, 3).map(r => `${r.url} (${r.time}ms)`).join('<br>')}
          </div>
        ` : ''}
        <div style="margin-top: 10px;">
          <button onclick="this.parentElement.remove()" 
                  style="padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer;">
            닫기
          </button>
          <button onclick="diagnoseProblem()" 
                  style="padding: 4px 8px; background: #007bff; color: white; border: none; border-radius: 3px; font-size: 11px; cursor: pointer; margin-left: 5px;">
            상세 진단
          </button>
        </div>
      `;
      
      // 5초 후 자동 닫기
      setTimeout(() => {
        if (testDiv.parentElement) {
          testDiv.remove();
        }
      }, 5000);
      
      console.log('연결 테스트 결과:', results);
    };

    // 🎯 향상된 에러 리포팅
    window.reportError = function(error, context) {
      const errorReport = {
        timestamp: new Date().toISOString(),
        error: error.message,
        stack: error.stack,
        context: context,
        userAgent: navigator.userAgent,
        url: location.href,
        apiBaseUrl: API_BASE_URL,
        chatId: currentChatId
      };
      
      console.error('에러 리포트:', errorReport);
      
      // 로컬 스토리지에 에러 저장 (선택사항)
      try {
        const errors = JSON.parse(localStorage.getItem('tourvis_errors') || '[]');
        errors.push(errorReport);
        if (errors.length > 10) errors.shift(); // 최대 10개만 유지
        localStorage.setItem('tourvis_errors', JSON.stringify(errors));
      } catch (e) {
        console.warn('에러 저장 실패:', e);
      }
    };

    // 전역 에러 핸들러
    window.addEventListener('error', (event) => {
      reportError(event.error || new Error(event.message), 'Global Error Handler');
    });

    window.addEventListener('unhandledrejection', (event) => {
      reportError(new Error(event.reason), 'Unhandled Promise Rejection');
    });

    // 서버 연결 테스트 버튼 추가
    const testDiv = document.createElement('div');
    testDiv.style.position = 'fixed';
    testDiv.style.bottom = '10px';
    testDiv.style.right = '10px';
    testDiv.style.zIndex = '1000';
    testDiv.innerHTML = `
      <button onclick="testServerConnection()" style="padding: 8px; background: #007bff; color: white; border: none; border-radius: 4px;">
        서버 연결 테스트
      </button>
    `;
    document.body.appendChild(testDiv);

    // 🎯 초기화 및 디버깅
    console.log('🖥️ 플랫폼 감지:', isMobile ? 'Mobile' : 'Desktop');
    console.log('🎯 전송 버튼 요소:', sendBtn);
    console.log('📝 입력 필드 요소:', input);
    console.log('🌐 API 엔드포인트:', `${API_BASE_URL}${CURRENT_CHAT_ENDPOINT}`);
    console.log('🔄 피드백 엔드포인트:', `${API_BASE_URL}${CURRENT_FEEDBACK_ENDPOINT}`);
    
    setTimeout(() => {
      if (!isMobile) {
        input.focus();
        console.log('🎯 입력 필드에 포커스 설정');
      }
    }, 500);
    
    // 🎯 모바일에서 키보드 올라올 때 대응
    if (isMobile) {
      let keyboardHeight = 0;
      
      window.addEventListener('resize', () => {
        const currentHeight = window.innerHeight;
        if (currentHeight < keyboardHeight - 100) {
          // 키보드가 올라온 상태
          setTimeout(() => {
            chat.scrollTop = chat.scrollHeight;
          }, 100);
        }
        keyboardHeight = currentHeight;
      });
      
      // 터치 스크롤 개선
      let touchStartY = 0;
      chat.addEventListener('touchstart', (e) => {
        touchStartY = e.touches[0].clientY;
      });
      
      chat.addEventListener('touchmove', (e) => {
        const touchY = e.touches[0].clientY;
        const scrollTop = chat.scrollTop;
        const maxScroll = chat.scrollHeight - chat.clientHeight;
        
        if ((scrollTop <= 0 && touchY > touchStartY) || 
            (scrollTop >= maxScroll && touchY < touchStartY)) {
          e.preventDefault();
        }
      }, { passive: false });
    }

    // 🎯 페이지 가시성 변경 시 포커스 관리
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && !input.disabled) {
        input.focus();
      }
    });
  </script>
</body>
</html>
